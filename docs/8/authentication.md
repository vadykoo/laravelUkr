# Аутентифікація

-   [Вступ](#introduction)
    -   [Огляд баз даних](#introduction-database-considerations)
    -   [Огляд екосистеми](#ecosystem-overview)
-   [Швидкий старт автентифікації](#authentication-quickstart)
    -   [Routing](#included-routing)
    -   [Views](#included-views)
    -   [Автентифікація](#included-authenticating)
    -   [Отримання автентифікованого користувача](#retrieving-the-authenticated-user)
    -   [Захист маршрутів](#protecting-routes)
    -   [Login Throttling](#login-throttling)
-   [Автентифікація користувачів вручну](#authenticating-users)
    -   [Запам'ятовування користувачів](#remembering-users)
    -   [Інші методи автентифікації](#other-authentication-methods)
-   [Базова автентифікація HTTP](#http-basic-authentication)
    -   [Базова автентифікація HTTP без статусу](#stateless-http-basic-authentication)
-   [Вихід](#logging-out)
    -   [Недійсні сеанси на інших пристроях](#invalidating-sessions-on-other-devices)
-   [Підтвердження паролю](#password-confirmation)
    -   [Конфігурація](#password-confirmation-configuration)
    -   [Routing](#password-confirmation-routing)
    -   [Захист маршрутів](#password-confirmation-protecting-routes)
-   [Соціальна автентифікація](/docs/{{version}}/socialite)
-   [Додавання Custom Guards](#adding-custom-guards)
    -   [Closure Request Guards](#closure-request-guards)
-   [Додавання користувацьких User Providers](#adding-custom-user-providers)
    -   [Provider Contract користувача](#the-user-provider-contract)
    -   [Автентифікаційний Contract](#the-authenticatable-contract)
-   [Події / Events](#events)

<a name="introduction"></a>

## Вступ

Laravel робить здійснення автентифікації дуже простим. Насправді майже все налаштовано для вас нестандартно. Файл конфігурації автентифікації знаходиться за адресою`config/auth.php`, який містить кілька добре задокументованих варіантів налаштування поведінки служб автентифікації.

По суті, засоби автентифікації Laravel складаються з "охоронців" та "постачальників". Охоронці визначають спосіб автентифікації користувачів для кожного запиту. Наприклад, Laravel корабель із`session`гвардія, яка підтримує стан за допомогою сховища сеансів та файлів cookie.

Постачальники визначають спосіб отримання користувачів із вашого постійного сховища. Laravel постачається з підтримкою отримання користувачів за допомогою Eloquent та конструктора запитів до бази даних. Однак ви можете вільно визначати додаткових постачальників, якщо це потрібно для вашої програми.

Не хвилюйтеся, якщо все це зараз звучить заплутано! Багатьом програмам ніколи не доведеться змінювати конфігурацію автентифікації за замовчуванням.

<a name="getting-started-fast"></a>

#### Початок роботи швидко

Хочете швидко розпочати? Встановити[Laravel Jetstream](https://jetstream.laravel.com)у свіжому додатку Laravel. Після міграції бази даних перейдіть до браузера`/register`або будь-яку іншу URL-адресу, призначену вашій програмі. Jetstream подбає про побудову всієї вашої системи автентифікації!

<a name="introduction-database-considerations"></a>

### Міркування щодо бази даних

За замовчуванням Laravel включає`App\Models\User`[Красномовна модель](/docs/{{version}}/eloquent)у вашому`app/Models`каталог. Цю модель можна використовувати із драйвером автентифікації Eloquent за замовчуванням. Якщо у вашій програмі не використовується Eloquent, ви можете використовувати`database`драйвер автентифікації, який використовує конструктор запитів Laravel.

При побудові схеми бази даних для`App\Models\User`моделі, переконайтеся, що стовпець пароля має не менше 60 символів. Збереження довжини стовпця за замовчуванням у 255 символів було б хорошим вибором.

Крім того, слід перевірити, що ваш`users`(або еквівалентна) таблиця містить атрибутивний рядок`remember_token`стовпець із 100 символів. Цей стовпець буде використовуватися для зберігання маркера для користувачів, які при вході у свою програму вибирають опцію "запам'ятати мене".

<a name="ecosystem-overview"></a>

### Огляд екосистеми

Laravel пропонує кілька пакетів, пов’язаних з аутентифікацією. Перш ніж продовжувати, ми розглянемо загальну екосистему автентифікації в Laravel та обговоримо цільове призначення кожного пакета.

Спочатку розглянемо, як працює автентифікація. Під час використання веб-браузера користувач надає своє ім’я користувача та пароль через форму входу. Якщо ці облікові дані є правильними, програма зберігатиме інформацію про автентифікованого користувача в цьому[сесія](/docs/{{version}}/session). Файл cookie, виданий браузеру, містить ідентифікатор сеансу, щоб подальші запити до програми могли асоціювати користувача з правильним сеансом. Після отримання файлу cookie сеансу програма отримає дані сеансу на основі ідентифікатора сеансу, зауважимо, що інформація про аутентифікацію зберігалася в сеансі, і буде вважати користувача "автентифікованим".

Коли для доступу до API віддаленій службі потрібно пройти автентифікацію, файли cookie зазвичай не використовуються, оскільки немає веб-браузера. Натомість віддалена служба надсилає маркер API до API на кожен запит. Додаток може перевірити вхідний маркер за таблицею дійсних токенів API та "аутентифікувати" запит, який виконується користувачем, пов'язаним із цим маркером API.

<a name="laravels-built-in-browser-authentication-services"></a>

#### Вбудовані служби автентифікації браузера Laravel

Laravel включає вбудовані послуги аутентифікації та сеансу, доступ до яких, як правило, здійснюється через`Auth`і`Session`фасади. Ці функції забезпечують автентифікацію на основі файлів cookie для запитів, що ініціюються веб-браузерами. Вони надають методи, що дозволяють перевірити облікові дані користувача та автентифікувати користувача. Крім того, ці служби автоматично зберігатимуть належні дані в сеансі користувача та видаватимуть належні файли cookie сеансу. Обговорення того, як користуватися цими послугами, міститься в цій документації.

**Jetstream / Fortify**

Як обговорюється в цій документації, ви можете взаємодіяти з цими службами автентифікації вручну, щоб створити власний рівень автентифікації вашої програми. Однак, щоб допомогти вам швидше розпочати роботу, ми випустили безкоштовні пакети, що забезпечують надійне, сучасне риштування всього рівня аутентифікації. Ці пакети є[Laravel Jetstream](https://jetstream.laravel.com)і[Laravel Fortify](https://github.com/laravel/fortify).

Laravel Fortify - це безглуздий сервіс автентифікації для Laravel, який реалізує багато функцій, знайдених у цій документації, включаючи автентифікацію на основі файлів cookie, а також інші функції, такі як двофакторна автентифікація та перевірка електронної пошти. Laravel Jetstream - це користувальницький інтерфейс, який використовує та розкриває послуги автентифікації Fortify завдяки чудовому, сучасному інтерфейсу, що працює від[CSS вітру хвоста](https://tailwindcss.com),[Laravel Livewire](https://laravel-livewire.com), та / або[Inertia.js](https://inertiajs.com). Laravel Jetstream, крім того, що пропонує аутентифікацію файлів cookie на основі браузера, включає вбудовану інтеграцію з Laravel Sanctum, щоб запропонувати аутентифікацію токенів API. Пропозиції автентифікації API Laravel розглядаються нижче.

<a name="laravels-api-authentication-services"></a>

#### Служби автентифікації API Laravel

Laravel пропонує два додаткові пакети, які допоможуть вам в управлінні маркерами API та аутентифікації запитів, зроблених за допомогою маркерів API:[Паспорт](/docs/{{version}}/passport)і[Святиня](/docs/{{version}}/sanctum). Зверніть увагу, що ці бібліотеки та вбудовані бібліотеки автентифікації на основі файлів cookie Laravel не є взаємовиключними. Ці бібліотеки головним чином зосереджуються на автентифікації маркера API, тоді як вбудовані служби автентифікації фокусуються на аутентифікації браузера на основі файлів cookie. Багато програм використовуватимуть як вбудовані служби автентифікації на основі файлів cookie, так і один із пакетів автентифікації API Laravel.

**Паспорт**

Passport - це постачальник аутентифікації OAuth2, який пропонує різноманітні «типи надання» OAuth2, які дозволяють видавати різні типи токенів. Загалом, це надійний та складний пакет для автентифікації API. Однак більшість програм не потребують складних функцій, пропонованих специфікацією OAuth2, що може заплутати як користувачів, так і розробників. Крім того, розробники історично заплутались у тому, як автентифікувати SPA-програми або мобільні додатки за допомогою постачальників автентифікації OAuth2, таких як Passport.

**Святиня**

У відповідь на складність OAuth2 та плутанину розробників ми вирішили створити простіший, спрощений пакет автентифікації, який міг би обробляти як власні веб-запити з веб-браузера, так і запити API через маркери. Ця мета була реалізована з виходом[Laravel святий](/docs/{{version}}/sanctum), який слід вважати кращим та рекомендованим пакетом автентифікації для додатків, які пропонують власний веб-інтерфейс на додаток до API, або забезпечуватимуться односторінковою програмою, яка існує окремо від внутрішньої програми Laravel або додатків які пропонують мобільний клієнт.

Laravel Sanctum - це гібридний пакет аутентифікації через Інтернет / API, який може керувати всім процесом автентифікації вашої програми. Це можливо, оскільки коли програми, засновані на Sanctum, отримують запит, Sanctum спочатку визначає, чи включає запит сеансовий файл cookie, який посилається на аутентифікований сеанс. Sanctum досягає цього за допомогою виклику вбудованих служб автентифікації Laravel, про які ми вже говорили раніше. Якщо запит не аутентифікується за допомогою сеансового файлу cookie, Sanctum перевірить запит на маркер API. Якщо присутній маркер API, Sanctum автентифікує запит за допомогою цього маркера. Щоб дізнатися більше про цей процес, зверніться до Sanctum's["як це працює"](/docs/{{version}}/sanctum#how-it-works)документація.

Laravel Sanctum - це пакет API, який ми вирішили включити до[Laravel Jetstream](https://jetstream.laravel.com)риштування автентифікації, оскільки ми вважаємо, що воно найкраще підходить для більшості потреб автентифікації веб-додатків.

<a name="summary-choosing-your-stack"></a>

#### Підсумок та вибір вашого стека

Таким чином, якщо доступ до вашої програми буде здійснюватися за допомогою браузера, програма використовуватиме вбудовані служби автентифікації Laravel.

Далі, якщо ваша програма пропонує API, ви можете вибрати між ними[Паспорт](/docs/{{version}}/passport)або[Святиня](/docs/{{version}}/sanctum)для забезпечення автентифікації маркера API для вашої програми. Загалом, Sanctum слід віддавати перевагу, коли це можливо, оскільки це просте, повне рішення для автентифікації API, аутентифікації SPA та мобільної автентифікації, що включає підтримку "обсягу" або "можливостей".

Паспорт можна вибрати, коли вашій програмі абсолютно потрібні всі функції, передбачені специфікацією OAuth2.

І якщо ви хочете швидко розпочати роботу, ми раді порадити[Laravel Jetstream](https://jetstream.laravel.com)як швидкий спосіб запустити нову програму Laravel, яка вже використовує бажаний стек автентифікації вбудованих служб автентифікації Laravel та Laravel Sanctum.

<a name="authentication-quickstart"></a>

## Швидкий старт автентифікації

> {note} У цій частині документації обговорюється аутентифікація користувачів через[Laravel Jetstream](https://jetstream.laravel.com)пакет, який включає будівельні ліси для інтерфейсу, щоб допомогти вам швидко розпочати роботу. Якщо ви хочете безпосередньо інтегруватися із системами автентифікації Laravel, ознайомтеся з документацією на[автентифікація користувачів вручну](#authenticating-users).

<a name="included-routing"></a>

### Маршрутизація

Ларавеля`laravel/jetstream`Цей пакет забезпечує швидкий спосіб побудови всіх всіх маршрутів, переглядів та іншої логіки сервера, необхідних для автентифікації, за допомогою декількох простих команд:

    composer require laravel/jetstream

    // Install Jetstream with the Livewire stack...
    php artisan jetstream:install livewire

    // Install Jetstream with the Inertia stack...
    php artisan jetstream:install inertia

Цю команду слід використовувати у нових програмах та встановлюватиме вигляд макета, подання реєстрації та входу, а також маршрути для всіх кінцевих точок автентифікації. A`/dashboard`Маршрут також буде створений для обробки запитів після входу в систему на інформаційну панель вашої програми.

<a name="creating-applications-including-authentication"></a>

#### Створення додатків, включаючи автентифікацію

Якщо ви запускаєте нову програму і хочете включити риштування для автентифікації, ви можете використовувати`--jet`при створенні програми за допомогою програми Laravel Installer. Ця команда створить нову програму з усіма складеними та встановленими лісами автентифікації:

    laravel new kitetail --jet

> {tip} Щоб дізнатись більше про Jetstream, відвідайте офіційного представника[Документація Jetstream](https://jetstream.laravel.com).

<a name="included-views"></a>

### Перегляди

Як зазначалося в попередньому розділі,`laravel/jetstream`пакет`php artisan jetstream:install`команда створить усі подання, необхідні для автентифікації, та розмістить їх у`resources/views/auth`каталог.

Jetstream також створить a`resources/views/layouts`каталог, що містить базовий макет для вашої програми. Усі ці погляди використовують[CSS вітру хвоста](https://tailwindcss.com)Framework, але ви можете налаштувати їх як завгодно.

<a name="included-authenticating"></a>

### Автентифікація

Тепер, коли вашу програму було створено для проведення автентифікації, ви готові зареєструватися та автентифікуватися! Ви можете просто отримати доступ до своєї програми у браузері, оскільки контролери автентифікації Jetstream вже містять логіку для автентифікації існуючих користувачів та зберігання нових користувачів у базі даних.

<a name="path-customization"></a>

#### Налаштування контуру

Коли користувач успішно аутентифікується, він, як правило, перенаправляється на`/home`URI. Ви можете налаштувати шлях перенаправлення після автентифікації, використовуючи`HOME`константа, визначена у вашому`RouteServiceProvider`:

    public const HOME = '/home';

При використанні Laravel Jetstream процес встановлення Jetstream змінить значення`HOME`константа до`/dashboard`.

<a name="retrieving-the-authenticated-user"></a>

### Отримання автентифікованого користувача

Під час обробки вхідного запиту ви можете отримати доступ до аутентифікованого користувача через`Auth`фасад:

    use Illuminate\Support\Facades\Auth;

    // Get the currently authenticated user...
    $user = Auth::user();

    // Get the currently authenticated user's ID...
    $id = Auth::id();

Як варіант, як тільки аутентифікація користувача, ви можете отримати доступ до аутентифікованого користувача через`Illuminate\Http\Request`інстанції. Пам'ятайте, підказкові класи автоматично вводитимуться у ваші методи контролера. За допомогою натякування типу`Illuminate\Http\Request`об'єкт, ви можете отримати зручний доступ до аутентифікованого користувача за допомогою будь-якого методу контролера у вашій програмі:

    <?php

    namespace App\Http\Controllers;

    use Illuminate\Http\Request;

    class FlightController extends Controller
    {
        /**
         * Get a list of all available flights.
         *
         * @param  Request  $request
         * @return Response
         */
        public function update(Request $request)
        {
            // $request->user() returns an instance of the authenticated user...
        }
    }

<a name="determining-if-the-current-user-is-authenticated"></a>

#### Визначення автентифікації поточного користувача

Щоб визначити, чи користувач вже ввійшов у вашу програму, ви можете використовувати`check`метод на`Auth`фасад, який повернеться`true`якщо аутентифікація користувача:

    use Illuminate\Support\Facades\Auth;

    if (Auth::check()) {
        // The user is logged in...
    }

> {tip} Незважаючи на те, що можна визначити, чи аутентифіковано користувача за допомогою`check`методом, ви зазвичай використовуєте проміжне програмне забезпечення для перевірки автентичності користувача, перш ніж надавати користувачеві доступ до певних маршрутів / контролерів. Щоб дізнатись більше про це, перегляньте документацію на[охоронні маршрути](/docs/{{version}}/authentication#protecting-routes).

<a name="protecting-routes"></a>

### Захист маршрутів

[Маршрутизуйте проміжне програмне забезпечення](/docs/{{version}}/middleware)може використовуватися, щоб дозволити лише аутентифікованим користувачам доступ до заданого маршруту. Laravel кораблі з`auth`проміжне програмне забезпечення, яке посилається на`Illuminate\Auth\Middleware\Authenticate`клас. Оскільки це проміжне програмне забезпечення вже зареєстроване у вашому ядрі HTTP, все, що вам потрібно зробити, це приєднати проміжне програмне забезпечення до визначення маршруту:

    Route::get('flights', function () {
        // Only authenticated users may enter...
    })->middleware('auth');

<a name="redirecting-unauthenticated-users"></a>

#### Перенаправлення неавторизованих користувачів

Коли`auth`проміжне програмне забезпечення виявляє неавторизованого користувача, воно перенаправляє користувача на`login`[названий маршрут](/docs/{{version}}/routing#named-routes). Ви можете змінити цю поведінку, оновивши`redirectTo`функція у вашому`app/Http/Middleware/Authenticate.php`файл:

    /**
     * Get the path the user should be redirected to.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return string
     */
    protected function redirectTo($request)
    {
        return route('login');
    }

<a name="specifying-a-guard"></a>

#### Вказівка ​​гвардії

При кріпленні`auth`проміжного програмного забезпечення до маршруту, ви також можете вказати, який охоронець слід використовувати для автентифікації користувача. Зазначений охоронець повинен відповідати одному з ключів у`guards`масив вашого`auth.php`файл конфігурації:

    Route::get('flights', function () {
        // Only authenticated users may enter...
    })->middleware('auth:api');

<a name="login-throttling"></a>

### Ввімкнення дроселювання

Якщо ви використовуєте Laravel Jetstream, обмеження швидкості автоматично застосовуватиметься до спроб входу. За замовчуванням користувач не зможе увійти в систему протягом однієї хвилини, якщо після декількох спроб не зможе надати правильні дані. Регулювання є унікальним для імені користувача / електронної адреси користувача та його IP-адреси.

> {tip} Якщо ви хочете оцінити обмеження власних маршрутів, перегляньте[документація, що обмежує норму](/docs/{{version}}/routing#rate-limiting).

<a name="authenticating-users"></a>

## Автентифікація користувачів вручну

Вам не потрібно використовувати риштування для автентифікації, що входить до складу Laravel Jetstream. Якщо ви вирішите не використовувати цей риштування, вам потрібно буде керувати автентифікацією користувачів за допомогою класів автентифікації Laravel безпосередньо. Не хвилюйся, це суть!

Ми отримаємо доступ до послуг автентифікації Laravel через`Auth`[фасад](/docs/{{version}}/facades), тому нам потрібно переконатися, що імпортуємо файл`Auth`фасад у верхній частині класу. Далі, давайте перевіримо`attempt`метод:

    <?php

    namespace App\Http\Controllers;

    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Auth;

    class LoginController extends Controller
    {
        /**
         * Handle an authentication attempt.
         *
         * @param  \Illuminate\Http\Request $request
         *
         * @return Response
         */
        public function authenticate(Request $request)
        {
            $credentials = $request->only('email', 'password');

            if (Auth::attempt($credentials)) {
                // Authentication passed...
                return redirect()->intended('dashboard');
            }
        }
    }

`attempt`метод приймає масив пар ключ / значення як перший аргумент. Значення масиву будуть використані для пошуку користувача в таблиці бази даних. Отже, у наведеному вище прикладі користувач отримає значення`email`стовпець. Якщо користувача знайдено, хешований пароль, що зберігається в базі даних, буде порівняно з`password`значення, передане методу через масив. Не слід хешувати пароль, зазначений як`password`value, оскільки фреймворк автоматично хешує значення перед порівнянням із хешованим паролем у базі даних. Якщо два хешовані паролі збігаються, для користувача буде запущено аутентифікований сеанс.

`attempt`метод повернеться`true`якщо автентифікація була успішною. В іншому випадку`false`буде повернено.

`intended`на редиректорі перенаправить користувача на URL-адресу, до якої він намагався отримати доступ, перш ніж перехопити проміжне програмне забезпечення для автентифікації. Цей метод може бути наданий резервний URI, якщо передбачуваний пункт призначення недоступний.

<a name="specifying-additional-conditions"></a>

#### Вказівка ​​додаткових умов

За бажанням ви можете також додати додаткові умови до запиту автентифікації на додаток до електронної пошти та пароля користувача. Наприклад, ми можемо перевірити, що користувач позначений як "активний":

    if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
        // The user is active, not suspended, and exists.
    }

> {note} У цих прикладах`email`не є обов’язковим варіантом, він просто використовується як приклад. Ви повинні використовувати будь-яке ім'я стовпця, яке відповідає "імені користувача" у вашій базі даних.

<a name="accessing-specific-guard-instances"></a>

#### Доступ до конкретних екземплярів Guard

Ви можете вказати, який екземпляр охорони ви хочете використовувати, використовуючи`guard`метод на`Auth`фасад. Це дозволяє керувати аутентифікацією для окремих частин вашого додатка, використовуючи повністю окремі моделі, що піддаються автентифікації, або таблиці користувачів.

Ім'я охоронця перейшло до`guard`метод повинен відповідати одному із охоронців, налаштованих у вашому`auth.php`файл конфігурації:

    if (Auth::guard('admin')->attempt($credentials)) {
        //
    }

<a name="manually-logging-out"></a>

#### Вихід

Для виходу користувачів із вашої програми ви можете використовувати`logout`метод на`Auth`фасад. Це очистить інформацію про автентифікацію в сеансі користувача:

    Auth::logout();

<a name="remembering-users"></a>

### Запам'ятовування користувачів

Якщо ви хочете надати у своїй програмі функціональність "запам'ятати мене", ви можете передати булеве значення як другий аргумент`attempt`метод, який зберігатиме автентифікацію користувача необмежений час або до виходу з нього вручну. Ваш`users`таблиця повинна містити рядок`remember_token`стовпець, який буде використовуватися для зберігання маркера "запам'ятати мене".

    if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
        // The user is being remembered...
    }

Якщо ви "пам'ятаєте" користувачів, ви можете використовувати`viaRemember`спосіб визначити, чи аутентифіковано користувача за допомогою файлу cookie "запам'ятати мене":

    if (Auth::viaRemember()) {
        //
    }

<a name="other-authentication-methods"></a>

### Інші методи автентифікації

<a name="authenticate-a-user-instance"></a>

#### Аутентифікуйте екземпляр користувача

Якщо вам потрібно зареєструвати існуючий екземпляр користувача у своїй програмі, ви можете зателефонувати до`login`метод з екземпляром користувача. Даний об'єкт повинен бути реалізацією`Illuminate\Contracts\Auth\Authenticatable`[контракт](/docs/{{version}}/contracts).`App\Models\User`модель, що входить до складу Laravel, вже реалізує цей інтерфейс. Цей метод автентифікації корисний, коли у вас вже є дійсний екземпляр користувача, наприклад безпосередньо після того, як користувач зареєструється у вашій програмі:

    Auth::login($user);

    // Login and "remember" the given user...
    Auth::login($user, true);

Ви можете вказати екземпляр охорони, який ви хотіли б використовувати:

    Auth::guard('admin')->login($user);

<a name="authenticate-a-user-by-id"></a>

#### Аутентифікуйте користувача за ідентифікатором

Для входу користувача до програми за його ідентифікатором ви можете використовувати`loginUsingId`метод. Цей метод приймає первинний ключ користувача, якого потрібно аутентифікувати:

    Auth::loginUsingId(1);

    // Login and "remember" the given user...
    Auth::loginUsingId(1, true);

<a name="authenticate-a-user-once"></a>

#### Один раз автентифікуйте користувача

Ви можете використовувати`once`метод входу користувача до програми для одного запиту. Жодні сеанси чи файли cookie використовувати не будуть, а це означає, що цей метод може бути корисним при створенні API без громадянства:

    if (Auth::once($credentials)) {
        //
    }

<a name="http-basic-authentication"></a>

## Базова автентифікація HTTP

[Базова автентифікація HTTP](https://en.wikipedia.org/wiki/Basic_access_authentication)забезпечує швидкий спосіб автентифікації користувачів вашої програми без налаштування спеціальної сторінки для входу. Для початку прикріпіть`auth.basic`[проміжне програмне забезпечення](/docs/{{version}}/middleware)до вашого маршруту.`auth.basic`проміжне програмне забезпечення входить до фреймворку Laravel, тому вам не потрібно його визначати:

    Route::get('profile', function () {
        // Only authenticated users may enter...
    })->middleware('auth.basic');

Як тільки проміжне програмне забезпечення буде приєднано до маршруту, вам автоматично буде запропоновано ввести облікові дані під час доступу до маршруту у вашому браузері. За замовчуванням`auth.basic`проміжне програмне забезпечення буде використовувати`email`стовпець на записі користувача як "ім'я користувача".

<a name="a-note-on-fastcgi"></a>

#### Примітка щодо FastCGI

Якщо ви використовуєте PHP FastCGI, автентифікація HTTP Basic може не працювати належним чином. Наступні рядки слід додати до вашого`.htaccess`файл:

    RewriteCond %{HTTP:Authorization} ^(.+)$
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

<a name="stateless-http-basic-authentication"></a>

### Базова автентифікація HTTP без статусу

Ви також можете використовувати базову автентифікацію HTTP, не встановлюючи в сеансі файл cookie ідентифікатора користувача, що особливо корисно для автентифікації API. Робити так,[визначити проміжне програмне забезпечення](/docs/{{version}}/middleware)що викликає`onceBasic`метод. Якщо відповідь не повертається`onceBasic`методом, запит може бути переданий далі в додаток:

    <?php

    namespace App\Http\Middleware;

    use Illuminate\Support\Facades\Auth;

    class AuthenticateOnceWithBasicAuth
    {
        /**
         * Handle an incoming request.
         *
         * @param  \Illuminate\Http\Request  $request
         * @param  \Closure  $next
         * @return mixed
         */
        public function handle($request, $next)
        {
            return Auth::onceBasic() ?: $next($request);
        }

    }

Далі,[зареєструйте маршрут проміжного програмного забезпечення](/docs/{{version}}/middleware#registering-middleware)і прикріпити його до маршруту:

    Route::get('api/user', function () {
        // Only authenticated users may enter...
    })->middleware('auth.basic.once');

<a name="logging-out"></a>

## Вихід

Щоб вручну вийти з програми, ви можете використовувати`logout`метод на`Auth`фасад. Це очистить інформацію про автентифікацію в сеансі користувача:

    use Illuminate\Support\Facades\Auth;

    Auth::logout();

<a name="invalidating-sessions-on-other-devices"></a>

### Недійсні сеанси на інших пристроях

Laravel також надає механізм анулювання та "виходу з системи" сеансів користувача, які активні на інших пристроях, без анулювання сеансу на їх поточному пристрої. Ця функція зазвичай використовується, коли користувач змінює або оновлює свій пароль, і ви хочете скасувати сеанси на інших пристроях, зберігаючи при цьому справжній пристрій автентифікованим.

Перед початком роботи слід переконатися, що`Illuminate\Session\Middleware\AuthenticateSession`проміжне програмне забезпечення присутнє і не коментується у вашому`app/Http/Kernel.php`клас '`web`група проміжного програмного забезпечення:

    'web' => [
        // ...
        \Illuminate\Session\Middleware\AuthenticateSession::class,
        // ...
    ],

Потім ви можете використовувати`logoutOtherDevices`метод на`Auth`фасад. Цей метод вимагає від користувача надати свій поточний пароль, який ваша програма повинна прийняти через форму введення:

    use Illuminate\Support\Facades\Auth;

    Auth::logoutOtherDevices($password);

Коли`logoutOtherDevices`метод, інші сеанси користувача будуть повністю визнані недійсними, що означає, що вони будуть "вийти з системи" усіх охоронців, якими вони раніше пройшли автентифікацію.

> {note} При використанні`AuthenticateSession`проміжне програмне забезпечення в поєднанні з назвою власного маршруту для`login`маршруту, ви повинні замінити`unauthenticated`на обробнику винятків вашої програми, щоб правильно перенаправити користувачів на вашу сторінку входу.

<a name="password-confirmation"></a>

## Підтвердження паролю

Створюючи додаток, іноді у вас можуть бути дії, які вимагають від користувача підтвердження свого пароля перед виконанням дії. Laravel включає вбудоване проміжне програмне забезпечення, щоб зробити цей процес легким. Реалізація цієї функції вимагатиме від вас визначення двох маршрутів: одного маршруту для відображення подання з проханням користувача підтвердити свій пароль та одного маршруту для підтвердження дійсності пароля та перенаправлення користувача до передбачуваного пункту призначення.

> {tip} У наступній документації обговорюється, як безпосередньо інтегрувати функції підтвердження пароля Laravel; однак, якщо ви хочете розпочати роботу швидше,[Laravel Jetstream](https://jetstream.laravel.com)Пакет аутентифікаційних лісів включає підтримку цієї функції!

<a name="password-confirmation-configuration"></a>

### Конфігурація

Після підтвердження свого пароля користувач не попросить підтвердити свій пароль ще протягом трьох годин. Однак ви можете налаштувати тривалість часу до того, як користувач отримає повторний запит на введення пароля, змінивши значення`password_timeout`значення конфігурації у вашому`auth`файл конфігурації.

<a name="password-confirmation-routing"></a>

### Маршрутизація

<a name="the-password-confirmation-form"></a>

#### Форма підтвердження пароля

Спочатку ми визначимо маршрут, необхідний для відображення подання з проханням підтвердити свій пароль від користувача:

    Route::get('/confirm-password', function () {
        return view('auth.confirm-password');
    })->middleware(['auth'])->name('password.confirm');

Як і слід було очікувати, подання, яке повертається цим маршрутом, повинно мати форму, що містить`password`поле. Крім того, не соромтеся включати до подання текст, який пояснює, що користувач входить до захищеної зони програми та повинен підтвердити свій пароль.

<a name="confirming-the-password"></a>

#### Підтвердження пароля

Далі ми визначимо маршрут, який буде обробляти запит на форму з подання "підтвердити пароль". Цей маршрут нестиме відповідальність за перевірку пароля та перенаправлення користувача за призначенням:

    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Hash;

    Route::post('/confirm-password', function (Request $request) {
        if (! Hash::check($request->password, $request->user()->password)) {
            return back()->withErrors([
                'password' => ['The provided password does not match our records.']
            ]);
        }

        $request->session()->passwordConfirmed();

        return redirect()->intended();
    })->middleware(['auth', 'throttle:6,1'])->name('password.confirm');

Перш ніж рухатись далі, давайте детальніше розглянемо цей маршрут. По-перше, запит`password`атрибут визначається таким чином, що він фактично відповідає паролю користувача, що пройшов аутентифікацію Якщо пароль дійсний, нам потрібно повідомити сеанс Laravel про те, що користувач підтвердив свій пароль.`passwordConfirmed`метод встановить мітку часу в сеансі користувача, яку Laravel може використовувати для визначення часу останньої підтвердження користувачем свого пароля. Нарешті, ми можемо перенаправити користувача за призначенням.

<a name="password-confirmation-protecting-routes"></a>

### Захист маршрутів

Ви повинні переконатися, що будь-якому маршруту, який виконує дію, яка вимагає нещодавнього підтвердження пароля, присвоєно`password.confirm`проміжне програмне забезпечення. Це проміжне програмне забезпечення входить до інсталяції Laravel за замовчуванням і автоматично зберігає призначене для користувача призначення в сеансі, щоб користувач міг бути перенаправлений у це місце після підтвердження свого пароля. Після збереження призначеного для користувача призначення у сеансі, проміжне програмне забезпечення перенаправить користувача на`password.confirm`[названий маршрут](/docs/{{version}}/routing#named-routes):

    Route::get('/settings', function () {
        // ...
    })->middleware(['password.confirm']);

    Route::post('/settings', function () {
        // ...
    })->middleware(['password.confirm']);

<a name="adding-custom-guards"></a>

## Додавання спеціальних гвардій

Ви можете визначити власні охоронці автентифікації, використовуючи`extend`метод на`Auth`фасад. Вам слід зробити цей дзвінок`extend`в межах a[постачальник послуг](/docs/{{version}}/providers). Оскільки Laravel вже поставляється з`AuthServiceProvider`, ми можемо розмістити код у цього постачальника:

    <?php

    namespace App\Providers;

    use App\Services\Auth\JwtGuard;
    use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
    use Illuminate\Support\Facades\Auth;

    class AuthServiceProvider extends ServiceProvider
    {
        /**
         * Register any application authentication / authorization services.
         *
         * @return void
         */
        public function boot()
        {
            $this->registerPolicies();

            Auth::extend('jwt', function ($app, $name, array $config) {
                // Return an instance of Illuminate\Contracts\Auth\Guard...

                return new JwtGuard(Auth::createUserProvider($config['provider']));
            });
        }
    }

Як ви можете бачити у наведеному вище прикладі, зворотний дзвінок передано до`extend` method should return an implementation of `Illuminate\Contracts\Auth\Guard`. Цей інтерфейс містить кілька методів, які вам потрібно буде застосувати для визначення власного захисту. Після того, як буде встановлено ваш спеціальний захист, ви можете використовувати цей захист у`guards`конфігурація вашого`auth.php`файл конфігурації:

    'guards' => [
        'api' => [
            'driver' => 'jwt',
            'provider' => 'users',
        ],
    ],

<a name="closure-request-guards"></a>

### Охоронці запитів на закриття

Найпростіший спосіб реалізації власної системи автентифікації на основі запитів HTTP - це використання`Auth::viaRequest`метод. Цей метод дозволяє швидко визначити процес автентифікації за допомогою одного закриття.

Для початку зателефонуйте на номер`Auth::viaRequest`метод у межах`boot`метод вашого`AuthServiceProvider`.`viaRequest`метод приймає ім'я драйвера автентифікації як перший аргумент. Це ім'я може бути будь-яким рядком, що описує ваш власний захист. Другим аргументом, що передається методу, має бути Закриття, яке отримує вхідний запит HTTP і повертає екземпляр користувача, або, якщо автентифікація не вдається,`null`:

    use App\Models\User;
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Auth;

    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        Auth::viaRequest('custom-token', function ($request) {
            return User::where('token', $request->token)->first();
        });
    }

Після того, як визначено ваш власний драйвер автентифікації, ви використовуєте його як драйвер у`guards`конфігурація вашого`auth.php`файл конфігурації:

    'guards' => [
        'api' => [
            'driver' => 'custom-token',
        ],
    ],

<a name="adding-custom-user-providers"></a>

## Додавання користувацьких постачальників послуг

Якщо ви не використовуєте традиційну реляційну базу даних для зберігання своїх користувачів, вам доведеться розширити Laravel за допомогою власного постачальника користувачів аутентифікації. Ми будемо використовувати`provider`метод на`Auth`фасад для визначення користувацького постачальника послуг:

    <?php

    namespace App\Providers;

    use App\Extensions\RiakUserProvider;
    use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
    use Illuminate\Support\Facades\Auth;

    class AuthServiceProvider extends ServiceProvider
    {
        /**
         * Register any application authentication / authorization services.
         *
         * @return void
         */
        public function boot()
        {
            $this->registerPolicies();

            Auth::provider('riak', function ($app, array $config) {
                // Return an instance of Illuminate\Contracts\Auth\UserProvider...

                return new RiakUserProvider($app->make('riak.connection'));
            });
        }
    }

Після реєстрації постачальника за допомогою`provider`Ви можете переключитися на нового постачальника користувачів у своєму`auth.php`файл конфігурації. Спочатку визначте a`provider`який використовує ваш новий драйвер:

    'providers' => [
        'users' => [
            'driver' => 'riak',
        ],
    ],

Нарешті, ви можете використовувати цього постачальника у своєму`guards`конфігурація:

    'guards' => [
        'web' => [
            'driver' => 'session',
            'provider' => 'users',
        ],
    ],

<a name="the-user-provider-contract"></a>

### Договір про надання послуг користувачем

`Illuminate\Contracts\Auth\UserProvider`реалізації відповідають лише за отримання`Illuminate\Contracts\Auth\Authenticatable`реалізація із стійкої системи зберігання, такої як MySQL, Riak тощо. Ці два інтерфейси дозволяють механізмам автентифікації Laravel продовжувати функціонувати незалежно від того, як зберігаються дані користувача або який тип класу використовується для їх представлення.

Давайте подивимось на`Illuminate\Contracts\Auth\UserProvider`контракт:

    <?php

    namespace Illuminate\Contracts\Auth;

    interface UserProvider
    {
        public function retrieveById($identifier);
        public function retrieveByToken($identifier, $token);
        public function updateRememberToken(Authenticatable $user, $token);
        public function retrieveByCredentials(array $credentials);
        public function validateCredentials(Authenticatable $user, array $credentials);
    }

`retrieveById`Функція, як правило, отримує ключ, що представляє користувача, наприклад, автоматично збільшується ідентифікатор з бази даних MySQL.`Authenticatable`реалізація, що відповідає ідентифікатору, повинна бути отримана і повернута методом.

`retrieveByToken`функція отримує користувача за його унікальним`$identifier`і "пам'ятай мене"`$token`, що зберігається в полі`remember_token`. Як і в попередньому методі,`Authenticatable`реалізацію слід повернути.

`updateRememberToken`метод оновлює`$user`поле`remember_token`з новим`$token`. Свіжий маркер призначається при успішній спробі входу в систему «запам’ятай мене» або коли користувач виходить із системи.

`retrieveByCredentials`метод отримує масив облікових даних, переданих в`Auth::attempt`метод при спробі входу в програму. Потім метод повинен "запитувати" базове постійне сховище для користувача, який відповідає цим обліковим даним. Зазвичай цей метод запускає запит із включеною умовою "де"`$credentials['username']`. Потім метод повинен повернути реалізацію`Authenticatable`.**Цей метод не повинен намагатися виконати перевірку пароля чи автентифікацію.**

`validateCredentials`метод повинен порівнювати поданий`$user`з`$credentials`для автентифікації користувача. Наприклад, цей метод, мабуть, слід використовувати`Hash::check`для порівняння значення`$user->getAuthPassword()`до значення`$credentials['password']`. Цей метод повинен повернутися`true`або`false`вказуючи, чи дійсний пароль.

<a name="the-authenticatable-contract"></a>

### Контракт, що підлягає автентифікації

Тепер, коли ми дослідили кожен із методів на`UserProvider`, давайте поглянемо на`Authenticatable`контракт. Пам'ятайте, що постачальник повинен повернути реалізації цього інтерфейсу з`retrieveById`,`retrieveByToken`, і`retrieveByCredentials`методи:

    <?php

    namespace Illuminate\Contracts\Auth;

    interface Authenticatable
    {
        public function getAuthIdentifierName();
        public function getAuthIdentifier();
        public function getAuthPassword();
        public function getRememberToken();
        public function setRememberToken($value);
        public function getRememberTokenName();
    }

Цей інтерфейс простий.`getAuthIdentifierName`метод повинен повертати ім'я поля "первинний ключ" користувача та`getAuthIdentifier`метод повинен повертати "первинний ключ" користувача. У фоновому режимі MySQL, знову ж таки, це буде первинний ключ із автоматичним збільшенням.`getAuthPassword`повинен повернути хешований пароль користувача. Цей інтерфейс дозволяє системі автентифікації працювати з будь-яким класом користувача, незалежно від того, який ORM або рівень абстракції сховища ви використовуєте. За замовчуванням Laravel включає a`User`класу в`app/Models`каталог, який реалізує цей інтерфейс, тому ви можете проконсультуватися з цим класом для прикладу реалізації.

<a name="events"></a>

## Події

Laravel виховує різноманітні[події](/docs/{{version}}/events)під час процесу автентифікації. Ви можете приєднати слухачів до цих подій у своєму`EventServiceProvider`:

    /**
     * The event listener mappings for the application.
     *
     * @var array
     */
    protected $listen = [
        'Illuminate\Auth\Events\Registered' => [
            'App\Listeners\LogRegisteredUser',
        ],

        'Illuminate\Auth\Events\Attempting' => [
            'App\Listeners\LogAuthenticationAttempt',
        ],

        'Illuminate\Auth\Events\Authenticated' => [
            'App\Listeners\LogAuthenticated',
        ],

        'Illuminate\Auth\Events\Login' => [
            'App\Listeners\LogSuccessfulLogin',
        ],

        'Illuminate\Auth\Events\Failed' => [
            'App\Listeners\LogFailedLogin',
        ],

        'Illuminate\Auth\Events\Validated' => [
            'App\Listeners\LogValidated',
        ],

        'Illuminate\Auth\Events\Verified' => [
            'App\Listeners\LogVerified',
        ],

        'Illuminate\Auth\Events\Logout' => [
            'App\Listeners\LogSuccessfulLogout',
        ],

        'Illuminate\Auth\Events\CurrentDeviceLogout' => [
            'App\Listeners\LogCurrentDeviceLogout',
        ],

        'Illuminate\Auth\Events\OtherDeviceLogout' => [
            'App\Listeners\LogOtherDeviceLogout',
        ],

        'Illuminate\Auth\Events\Lockout' => [
            'App\Listeners\LogLockout',
        ],

        'Illuminate\Auth\Events\PasswordReset' => [
            'App\Listeners\LogPasswordReset',
        ],
    ];
